<!DOCTYPE HTML>
<html>
<head>
	<title>STEALTH 'em UP</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			origin_marker-color: #000000;
		}

		#help{
			position: absolute;
			z-index: 20;
			color: black;
			top: 20px;
			left: 120px;
		}
	</style>

	<script src="../../bin/pixi.dev.js"></script>
	
</head>
<body>
    
    <script src="js/jo_debug.js"></script>
    <script src="js/jo_math.js"></script>
	<script src="js/jo_sprite.js"></script>
	<script src="js/jo_cam.js"></script>
	<script src="js/jo_utility.js"></script>
    <script>
    var window_properties = {width: 620, height: 400};
    var mouse, hero_aim;
    var keys = {w: false, a: false, s: false, d: false, space:false};
	// create an new instance of a pixi stage
	// the second parameter is interactivity...
	var interactive = true;
	var stage = new PIXI.Stage(0xEEEEEE, interactive);
	// create a renderer instance.
	var renderer = PIXI.autoDetectRenderer(window_properties.width, window_properties.height);
	// add the renderer view element to the DOM
	document.body.appendChild(renderer.view);
	requestAnimFrame(animate);
    
    
    var camera = new jo_cam(window_properties);
    var hero_line = new debug_line();
    var test_cone = new debug_line();
    var hero_cir = new debug_circle();
    // create a text object that will be updated..
    var countingText = new PIXI.Text("Mouse Pos:", { font: "20px Arial", fill: "#000000", align: "center", stroke: "#FFFFFF", strokeThickness: 2 });
    countingText.position.x = 0;
    countingText.position.y = 0;
    countingText.anchor.x = 0;
    stage.addChild(countingText);

    //images:
    var img_orange = PIXI.Texture.fromImage("orange2.png");
    var img_blue = PIXI.Texture.fromImage("blue.png");
    var img_skull = PIXI.Texture.fromImage("skull.png");
    

    
    //make sprites
    var hero = new jo_sprite(new PIXI.Sprite(img_blue));
    hero.speed = 2;
    var hero_drag_target = null; // a special var reserved for when the hero is dragging something.
    var guards = [];
    guards.push(new jo_sprite(new PIXI.Sprite(img_orange)));
    guards.push(new jo_sprite(new PIXI.Sprite(img_orange)));
    guards.push(new jo_sprite(new PIXI.Sprite(img_orange)));
    //randomize guards positions
    for(var i = 0; i < guards.length; i++){
            guards[i].x = i*100;
            guards[i].y = i*100;
        
    }
    

    
	var origin_marker = new jo_sprite(PIXI.Sprite.fromImage("origin.png"));
    
    function gameloop(){
        
        //update mouse
        mouse_rel = stage.getMousePosition();//gets relative mouse position
        mouse = camera.objectivePoint(mouse_rel);
        //countingText.setText("Mouse: " + Math.round(mouse.x) + " " + Math.round(mouse.y));
        
        //update hero directions based on keys:
        if(keys.w){
            hero.target.y = hero.y - 100;
        }else if(keys.s){
            hero.target.y = hero.y + 100;
        }else hero.target.y = hero.y;
        if(keys.d){
            hero.target.x = hero.x + 100;
        }else if(keys.a){
            hero.target.x = hero.x - 100;
        }else hero.target.x = hero.x;
     
        
        
        
        //update all sprites:
        origin_marker.prepare_for_draw();
        
        //////////////////////////////////////////////////
        //////////////////////////////////////////////////
        //examples of using debug shapes
        hero_aim = new Ray(hero.x,hero.y,mouse.x,mouse.y);
        hero_line.draw_Ray(hero_aim);
        //hero_cir.draw_obj(0,0,50);
        
        hero.move_to_target();
        hero.prepare_for_draw();
        if(hero_drag_target)hero.sprite.rotation += Math.PI;//reverse the hero's rotation because he is dragging something.
        
        for(var i = 0; i < guards.length; i++){
            hero_cir.draw_obj(guards[i].x,guards[i].y,200);
            if(guards[i].alive){
                if(get_distance(hero.x,hero.y,guards[i].x,guards[i].y) < 200){
                    //if the guards is close enough to the hero to see him, agro
                    var visionConeAngleForHero = guards[i].angleBetweenSprites_relativeToThis(hero);
                    countingText.setText("Ang: " + visionConeAngleForHero);
                    if(visionConeAngleForHero <= 1.22 && visionConeAngleForHero >= -1.22){
                        //if the hero is within the guard's vision cone (1.22 rad ~== 70 degrees)
                        guards[i].target = hero;
                        
                    }else guards[i].target = guards[i];
                    
                }else guards[i].target = guards[i];
                guards[i].move_to_target();
            }
            guards[i].prepare_for_draw();
        }

        
        //move hero's drag target:
        if(hero_drag_target){
            hero_drag_target.target = hero;//the drag target is "following" the hero.
            hero_drag_target.move_to_target();
            //hero_drag_target.prepare_for_draw();//not necessary - should already be prepared in another line of code
        }
        
        //set camera on hero
        camera.x = hero.x;
        camera.y = hero.y;
        
        

    }

	function animate() {
        gameloop();
	    // render the stage
	    renderer.render(stage);

	    requestAnimFrame(animate);	
        
    
        
	}
    

    window.onkeydown = function(e){
        var code = e.keyCode ? e.keyCode : e.which;
        //keyinfo[code] = String.fromCharCode(code);
        if(code == 87){keys['w'] = true;}
        if(code == 65){keys['a'] = true;}
        if(code == 83){keys['s'] = true;}
        if(code == 68){keys['d'] = true;}
        if(code == 32){
            keys['space'] = true;
            if(hero_drag_target){
                //drag is a toggle action so release current drag target.
                hero_drag_target = null;
                //bring hero speed back to normal
                hero.speed = hero.speed*2;
            }else{
                //check if any dead guards are close enough to be dragged.
                for(var i = 0; i < guards.length; i++){
                    if(!guards[i].alive && get_distance(hero.x,hero.y,guards[i].x,guards[i].y) <= unit_radius*2){
                        //slow down hero speed because he just started dragging something.
                        hero.speed = hero.speed/2;
                        hero_drag_target = guards[i];
                        hero_drag_target.speed = hero.speed;
                        hero_drag_target.stop_distance = unit_radius*2;//I don't know why but the stop distance here seems to need to be bigger by a factor of 10

                    }
                        
                    
                }
            }
        }
        
    };
    window.onkeyup = function(e){
        var code = e.keyCode ? e.keyCode : e.which;
        if(code == 87){keys['w'] = false;}
        if(code == 65){keys['a'] = false;}
        if(code == 83){keys['s'] = false;}
        if(code == 68){keys['d'] = false;}
        if(code == 32){keys['space'] = false;}
        
    };
    var test;
    window.onclick = function(e){
        mouse_click_obj = camera.objectivePoint(e);  //uses e's .x and .y to find objective click
        
        //what happens on mouse click:
        
        
        //check if hero aim intersects guard:
        for(var i = 0; i < guards.length; i++){
            if(circle_ray_intersect(guards[i].getCircleInfoForUtilityLib(),hero_aim)){
                guards[i].sprite.setTexture(img_skull);
                guards[i].alive = false;
            
            }
        
        }
    
    }
    
    

	</script>
	</body>
</html>
